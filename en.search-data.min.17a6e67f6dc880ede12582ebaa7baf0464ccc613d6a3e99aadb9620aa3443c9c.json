[{"id":0,"href":"/posts/Hello-Protobuf/","title":"看了下 Protobuf","section":"Posts","content":"RPC RPC，全称 Remote Procedure Call，中文叫远程过程调用。\ngo 语言基于标准库实现了一套自己的 RPC 调用规则：方法只能有两个可序列化的参数，其中第二个参数是指针类型，并且返回一个error类型，同时必须是公开的方法1。\n Only methods that satisfy these criteria will be made available for remote access; other methods will be ignored:\n - the method's type is exported. - the method is exported. - the method has two arguments, both exported (or builtin) types. - the method's second argument is a pointer. - the method has return type error.  In effect, the method must look schematically like\n func (t *T) MethodName(argType T1, replyType *T2) error 举个例子 定义函数\ntype HelloService struct { } func (h *HelloService) SayHello(s string, sp *string) error { fmt.Println(\u0026#34;hello func\u0026#34;, s, sp) return nil } server.go\nfunc main() { rpc.RegisterName(\u0026#34;HelloService\u0026#34;, new(proto.HelloService)) listener, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;:6666\u0026#34;) if err != nil { panic(err) } conn, err := listener.Accept() if err != nil { panic(err) } rpc.ServeConn(conn) } client.go\nfunc main() { client, err := rpc.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;localhost:6666\u0026#34;) if err != nil { log.Fatal(\u0026#34;dialing:\u0026#34;, err) } var reply string err = client.Call(\u0026#34;HelloService.SayHello\u0026#34;, \u0026#34;param\u0026#34;, \u0026amp;reply) if err != nil { log.Fatal(err) } fmt.Println(reply) //hello func param 0xc00009d390 } 也可以参考这个 https://snassr.io/post/0005_tcprpcserver/\n这样在 go 语言内部也可以直接使用 RPC 调用了。但是也就仅限于 go 语言的项目之间的通信，如果要跨语言，还需要一套标准的描述语言来定义自己有什么方法供别人使用，那就有请 Protobuf。\nProtobuf Protobuf 作为接口规范的描述语言，可以作为设计安全的跨语言 RPC 接口的基础工具。\n举个例子 定义函数\ntype HelloService struct { } func (h *HelloService) SayHello(s string, sp *string) error { fmt.Println(\u0026#34;hello func\u0026#34;, s, sp) return nil } 编写 protobuf 文件\nsyntax = \u0026#34;proto3\u0026#34;; package proto; service HelloService { rpc SayHello(HelloRequest) returns (HelloResponse); } message HelloRequest { string name = 1; string name_pointer = 2; } message HelloResponse { } 生成 hello.pb.go 文件\nprotoc --go_out=. proto/hello.proto # 如果使用 gRPC 框架 protoc --go_out=plugins=grpc:. proto/hello.proto 使用 gRPC 框架定义 server 和 client\nServer和 Client 代码参考官方 Helloworld https://github.com/grpc/grpc-go/tree/master/examples/helloworld\nProtobuf 进阶语法 中文资料2不多，可以直接参考官方文档3\ngRPC gRPC是基于HTTP/2 协议、使用 Protobuf 作为接口描述语言的一套完整的 RPC 远程调用框架。\n  net/rpc 标准库文档 https://golang.org/pkg/net/rpc/ \u0026#x21a9;\u0026#xfe0e;\n Protobuf3 语法指南 https://colobu.com/2017/03/16/Protobuf3-language-guide/ \u0026#x21a9;\u0026#xfe0e;\n Protobuf 官方文档 https://developers.google.com/protocol-buffers/docs/overview \u0026#x21a9;\u0026#xfe0e;\n   "},{"id":1,"href":"/posts/pingpang-financing/","title":"乒乓理财，了解一下？","section":"Posts","content":"谁需要看 如果你有100 万要理财，这个不适合你。如果你只有 1 万？那向你介绍一下我总结的理财方案~\n认识乒乓球拍 关于球拍的分类，我从各个角度出发整理了一个图：\n可见，正是球拍的种类非常之多，每种特性组合在一起，会发生各种各样的效果，这也是为什么球友们对器材津津乐道、各种尝试的原因，也是乒乓球拍多样性表现，况且现在还没有介绍胶皮的多样性。\n案例分析 张继科和VIS 先说蝴蝶 Viscaria 这款球拍，说 VIS 不得不提张继科，说张继科成就了蝴蝶也不过分，十位大满贯选手之一，并且用了最短时间拿到大满贯这个称号，称得上帝国的猛虎。加上他桀骜不驯的人设，喜欢的人自然很多，在张继科还没出名的时候，VIS 是给 Tim Boll 用的，不愠不火，直到后来张继科横空出世，瞬间带火了 VIS 结构的球拍，七夹外置ALC，如今各大品牌基本都有 VIS 结构的拍子作为主打产品，但还是仍不如 VIS 火，可见业余选手挑选底板这个领域，粉丝效应非常明显。\n并不是所有的 VIS 都火爆，准确的说，越接近 2012 年张继科拿到伦敦奥运会冠军那一年，价格越贵，VIS 也就越有收藏价值，随着蝴蝶工艺水平的提高，手感真的说不上比现在好。\n   年份 码号 闲鱼全新价格（仅供参考）     2011 L 5500   2012 M 4000   2013 N 3000+   2014 O 2600   2015 P 2200   2016 Q 1800   2017 R 1500   2018 S 1200   2019 T 1100   2020 U 1000    金标 VIS 2018 年蝴蝶开始在大陆发售金标VIS，市场价 1800，如今每块金标 VIS 在闲鱼的全新价格，基本在 2200 以上，我见到过品相十分好的可以卖到 3000-4000。\n柳承敏和红柳 g-max 柳承敏最好的成绩是 2004 年雅典奥运会赢了王皓拿到男子单打冠军。\n红柳是一款日式直拍，我的红柳打了三年，今年直改横了，这块球拍上学的时候特别贵，馋了好多年，从小看柳承敏打球也看了好几年，一直到毕业了自己挣钱才从日本代购来的，结果没过多久就停产了。在我看来柳承敏对很多打日直的朋友来说都是一种信念，他的风格提醒我们在球场上不放弃任何一个球，日直打的就是搏杀，所以这块球拍更能显出珍贵，让人热血沸腾。\n因为停产，我在 16 年底 1700 市场价买的球拍，现在闲鱼全新的球拍基本在 4000+。同是日直的还有金泽洙底板，因为更稀少，年代更久，现在同品相价格比柳承敏还要稍微贵一点。\n庄智渊、陈建安限量 2013年，庄智渊与陈建安搭挡，在法国巴黎所举办的乒乓球顶级赛事世界乒乓球锦标赛拿下男双冠军，为台湾选手首度于世锦赛夺金。蝴蝶为了纪念他们这一次比赛成绩，发布了庄智渊 350 枚+ 陈建安 250 枚球拍。\n这两块球拍除去到底好不好用不说，因为很少有人真的拆开打了。从 14 年发售时首发各 1500 左右的价格，到现在两枚对拍能买到 10000，由此可见限量的抬价能力。\n马龙和红双喜 W968 关于红双喜我能说的也不多，毕竟国民级品牌人人都懂，W968 也分等级，而且渠道都有货，水深得很。\n   型号 全新价格（仅供参考）     龙五（市场版） 650   字母 968（省队使用） 2000+   数字 968（国家队使用） 4500+     为什么球拍会涨价 球拍作为一个消耗品为什么会涨价，我想到了下面这几点原因。\n粉丝效应 张继科就是最明显的例子，不过这个粉丝更多可能不是娱乐圈的粉丝，而是球迷，如果你相对马龙而言更喜欢张继科的打球风格，那么你大概率会优先选择 vis 或者超级张继科这几款底板，而不会选择 W968。\n国家队就是风向标 除了有代言的超级球员，现在国家队基本就是两大阵营，一边是外置的金标 Vis，另一边就是内置的 W968，所以这两款球拍的需求一直都很稳定，全新的球拍价格超级高，品相好的可能是市场价的两倍也不奇怪。\n市场巨大 中国人口 14 亿，乒乓球是国球，不多解释。\n体育精神 在我看来柳承敏就是很好的例子（我觉得有体育精神），如果说一定要讨论韩国体育精神这个话题，我能说的其实也很少。\n中国就更不缺体育精神的代言人了吧，每个球友心中都有自己的最佳球员，可能是许昕、可能是樊振东、马龙。\n木材的资源有限 球拍本身对木材的特性要求就很高，满足要求的木材种类也相对较少，最后又能达到商品质量的更是少之又少，这也是为什么日本产的桧木，一小块木头做成 10mm 厚的球拍可以卖到 2000 元的原因吧。\n品相 同样的型号，品相好的更好卖，这个闲鱼可以证明，即使是全新的相同型号球拍也是一个拍一个价。\n限量 有纪念意义，同时一般限量版都是特注工坊制作的，比一般市场版球拍的用料肯定要相对好一些，这个特注工坊出品的金标 vis 、特注 vis 可以证明。\n停产 球拍停产的原因有很多，不光是因为厂家觉得没市场了，还有一个比较常见的原因是比如一个球员在巅峰时期和蝴蝶签了 10 年，10 年后球拍仍然有市场，但是球员已经退役没有续签必要了，这个以该球员命名的球拍就只能停产了。\n发行公司 首先发行公司决定了产品的性能、品控。如果说各品牌球拍性能差异不大，那么品控很有可能是价格是否坚挺的决定原因，从这个角度看，蝴蝶绝对是品控最好的公司，没有之一，是吧拉丝卡？\n男性球员代言的球拍需求更高 这个很好理解，如果蝴蝶发售了市场价都为 1000 元的球拍，一段时间后，一般男性球员的球拍的价格要比女性球员的球拍更坚挺，有可能还会涨价，毕竟在业余球友里，在日常的球馆里，女性球友有十分之一就不错了。\n涨价与什么无关 有一些原因会导致涨价，有一些因素不会妨碍涨价，我也想到了几点。\n与国家无关 你会发现我举了很多例子都不是中国的选手和中国的公司，说明即使是乒乓大国的中国，包容性也是非常强，大家并不是只支持国货，更多是根据自己的需求来选球拍。\n如果你“投资”能赚多少钱 答案可能是大概率会亏钱，但不会亏太多，毕竟一共才一万块钱的买卖。\n为什么这么说，两个字：外行，原因有以下几个：\n  不关注比赛，也就不了解专业选手的打球特点和球拍的关系，相当于没有指导思想\n  不了解业余选手的特点、喜好、诉求，也就不了解市场\n  自己不打球，对球拍性能没有自己的认识，说服不了自己也就说服不了别人\n  大胆预测 为什么现在还可以预测哪款球拍涨价？依据是什么？现在市场上的产品有什么好预测的呢？\n眼看 2020 东京奥运会要开始了，过了 4 年新的世界霸主是谁现在还真不知道，求别再说马龙和张继科了，起码提一下樊振东也还好，但是世界舞台还是有新星诞生的。在我看来最值得一提的是台湾小将林昀儒，林应该是一位天赋型选手，但他的天赋不是身体天赋，而是头脑天赋，打球非常有灵性，预判准确，回球犀利。\n林昀儒用的是超级张继科，就是那块“自动上台”的球拍，超张也是现在市场上最贵的球拍之一，闲鱼国行全新也在 1900 以上。所以我第一看好的就是这块球拍。哪怕东京奥运会，林昀儒拿不到冠军，我觉得前三还是很有竞争力的，所以超张短时间内也不会贬值。\n另一个新星选手就是日本的张本智和，蝴蝶也为他出了两块新球拍，张本智和的内置 super ZLC和张本智和外置 ALC，不过张本最近的成绩也起起伏伏，最稳定的我还是看好林昀儒。\n不推荐马龙的 W968，红双喜的保值能力不行，加上本来也是内置球拍，真正能发挥出来性能的人相对较少。\n据说今年还会出超级林高远和超级波尔，值得关注下，具体还要看结构。\n总结预测结果 这几款球拍在未来一段时间价格肯定不会跳水。\n   型号 关联的选手 预测原因     金标VIS 林高远、樊振东、张继科 每年限量发售，VIS 外置结构本身也是比较适合业余选手的，从实用角度看需求并不低，而且是每年蝴蝶特注工坊限量发行。   超级张继科 林昀儒、张继科 张继科不用说了，林昀儒可以说是近几年强势崛起，多次在大小比赛战胜国内高手。   超级张本智和 张本智和 张本成绩也不稳定，技术特点也被国家队研究透了，得冠军很难，但是在现在国际乒联的规则下，拿个名次还是很有可能的。    免责   云高手太多，笔者对手感的观点不接受反驳，毕竟每个人描述起来有偏差。\n  赔钱了更别找我啊，我只是拿真实的案例举例子而已。\n  通货膨胀。如果你说 3 年前卖 1800，现在卖 2200 算通胀的话也不能算涨价，那就按你的理解，可以说没涨价。\n  推荐  对乒乓球感兴趣，强烈推荐动漫 《乒乓》 对比赛和选手感兴趣，推荐下载个体育中国APP，每周甚至每天都有比赛。 开球网了解一下，顺便参加个积分赛？  参考  常见乒乓底板结构     品牌 型号 结构 面料 力材 大芯 类型     Banda Carrera 淋巴+阿尤丝+阿尤丝+阿尤丝+淋巴 淋巴 阿尤丝 阿尤丝 5木   Banda Carrera RS 淋巴+活力木+阿尤丝+活力木+淋巴 淋巴 阿尤丝 阿尤丝 5木   DHS 狂飙皓 koto+云杉+阿尤丝+云杉+koto koto 云杉 阿尤丝 5木   DHS 狂飙皓2 656 淋巴+云杉+阿尤丝+云杉+淋巴 淋巴 云杉 阿尤丝 5木   DHS 狂飙皓3 （0.6mm）竖纹染色KOTO+（2.1mm）横纹阿尤斯+（0.3mm）芳碳 koto 阿尤丝 玻碳 4木+1碳   DHS 狂飙龙 506 limba+ayous横+ayous纵+ayous横大心 淋巴 阿尤丝 阿尤丝 7木   DHS 劲极7 limba+ayous横+ayous纵+ayous横大心 淋巴 阿尤丝 阿尤丝 7木   DHS 劲极9 limba+ayous横+ayous纵+ayous横大心 淋巴 阿尤丝 阿尤丝 7木   DHS 狂飙王 koto+云杉+阿尤丝+云杉+koto koto 云杉 阿尤丝 5木   DHS 狂飙王2 655 koto+云杉+阿尤丝+云杉+koto koto 云杉 阿尤丝 5木   DHS 狂飙王3 Koto, Spruce, Fiberglass, Carbon, Ayous koto 云杉 阿尤丝 5木+2碳   Donic 都特 碳 0,6 Limba+0,6 Limba+碳+4,0 Dotec-Balsa 淋巴 淋巴 轻木 5木+2碳   Donic 都特 OFF 0,6 Hinoki +Dotec+0,6 Koto+ 5,0 Dotec-Balsa 桧木 koto 轻木 5木+2碳   Donic 都特 AR 0,6 Limba+Dotec+0,6 Limba+4,5 Dotec-Balsa 淋巴 淋巴 轻木 5木+2碳   Donic 奥恰 胡桃木+阿尤丝+阿尤丝+阿尤丝+阿尤丝+阿尤丝+胡桃木 胡桃木 阿尤丝 阿尤丝 7木   Joola Viva 淋巴（0.25mm）+阿尤斯（0.75mm）+阿尤斯（1.5mm）+阿尤斯（1.75mm） 淋巴 阿尤丝 阿尤丝 7木   Joola 黑森林 胡桃木+云杉+阿尤丝+云杉+胡桃木 胡桃木 云杉 阿尤丝 5木   Nittaku 大鸟 淋巴（0.25mm）+阿尤斯（0.75mm）+阿尤斯（1.5mm）+阿尤斯（1.75mm） 淋巴 阿尤丝 阿尤丝 7木   Nittaku 黑玻鸟羽 黑胡桃+玻纤+阿尤斯横+阿尤斯纵+阿尤斯横+阿尤斯纵+阿尤斯横+玻纤+黑胡桃 胡桃木 阿尤丝 阿尤丝 7木   Nittaku R5 koto+云杉+阿尤丝+云杉+koto koto 云杉 阿尤丝 5木   Nittaku 王楠 koto+云杉+阿尤丝+云杉+koto koto 云杉 阿尤丝 5木   Nittaku 黑鸟羽 胡桃木+阿尤丝+阿尤丝+阿尤丝+阿尤丝+阿尤丝+胡桃木 胡桃木 阿尤丝 阿尤丝 7木   Nittaku 木吉他 limba-limba-tung tree-limba-limba 淋巴 淋巴 油桐 5木   Nittaku Septear 桧木+桧木+桧木+桧木+桧木+桧木+桧木 桧木 桧木 桧木 7木   Nittaku 石川佳纯 limba+limba+阿尤丝+limba+limba 淋巴 淋巴 阿尤丝 5木   Nittaku 小鸟 淋巴（0.25mm）+阿尤斯（0.75mm）+阿尤斯（1.5mm）+阿尤斯（1.75mm） 淋巴 阿尤丝 阿尤丝 7木   Nittaku 小提琴 白蜡木+白蜡木+桐木大芯+白蜡木+白蜡木 白蜡木 白蜡木 油桐 5木   Sitga AC 淋巴+阿尤丝+阿尤丝+阿尤丝+淋巴 淋巴 阿尤丝 阿尤丝 5木   Sitga AE 淋巴+阿尤丝+阿尤丝+阿尤丝+淋巴 淋巴 阿尤丝 阿尤丝 5木   Sitga CL 淋巴（0.25mm）+阿尤斯（0.75mm）+阿尤斯（1.5mm）+阿尤斯（1.75mm） 淋巴 阿尤丝 阿尤丝 7木   Sitga EG 淋巴+活力木+阿尤丝+活力木+淋巴 淋巴 阿尤丝 阿尤丝 5木   Sitga 纳米OC 淋巴竖纹（0.6mm）+云杉横（0.8mm）+阿尤丝竖纹（3.5） 淋巴 云杉 阿尤丝 5木   Sitga OC 淋巴竖纹（0.6mm）+云杉横（0.8mm）+阿尤丝竖纹（3.5） 淋巴 云杉 阿尤丝 5木   Sitga OC（黄标） KOTO竖纹（0.6mm）+云杉横（0.8mm）+阿尤丝竖纹（3.5） koto 云杉 阿尤丝 5木   Sitga TO 淋巴+阿尤丝+阿尤丝+阿尤丝+淋巴 淋巴 阿尤丝 阿尤丝 5木   Sitga VPS 淋巴+云杉+阿尤丝+云杉+淋巴 淋巴 云杉 阿尤丝 5木   Sitga 枫木5 枫木（0.6mm）+云杉（0.8mm）+阿尤斯大心（3.2mm） 枫木 云杉 阿尤丝 5木   Sitga 枫木7 枫木（0.6mm）+阿尤斯横（0.8mm）+云杉横（0.8mm）+阿尤斯大心（2.0mm） 枫木 云杉 阿尤丝 7木   Sitga 黑檀5 黑檀（0.55mm）+云杉（0.8mm）+阿尤斯大心（3.3mm） 黑檀 云杉 阿尤丝 5木   Sitga 黑檀7 黑檀+AYOUS+黑檀+AYOUS+黑檀+AYOUS+黑檀 黑檀 阿尤丝 阿尤丝 7木   Sitga 玫瑰5 玫瑰木（0.5mm）+云杉（0.8mm）+阿尤斯大心（3.5mm） 玫瑰木 云杉 阿尤丝 5木   Sitga 玫瑰7 玫瑰木（0.5mm）+阿尤斯（0.752）层+阿尤斯（1.453层） 玫瑰木 阿尤丝 阿尤丝 7木   Xiom 时代帝王 koto-aramid carbon-ayous-kiri-ayous-aramid carbon-koto koto 阿尤丝 梧桐 5木+2碳   Yasaka YE 安哥利+淋巴+阿尤丝+淋巴+安哥利 安哥利 淋巴 阿尤丝 5木   Yasaka YEO 胡桃木+云杉+阿尤丝+云杉+胡桃木 胡桃木 云杉 阿尤丝 5木   Yasaka YES 胡桃木+阿尤丝+阿尤丝+阿尤丝+阿尤丝+阿尤丝+胡桃木 胡桃木 阿尤丝 阿尤丝 7木   Yasaka YO40 林巴+阿尤斯+阿尤斯+染色阿尤斯 淋巴 阿尤丝 阿尤丝 7木   Yasaka 马琳碳 林巴/柳桉/碳/阿优丝/碳/柳桉/林巴 淋巴 柳桉 阿尤丝 5木+2碳   Yasaka 马软碳 安哥利/林巴/软碳/阿优丝/软碳/林巴/安格利 安哥利 淋巴 阿尤丝 5木+2碳   蝴蝶 Maze limba-arylate/carbon-limba-ayous-limba-arylate/carbon-limba 淋巴 淋巴 阿尤丝 5木+2碳   蝴蝶 TAKSIM 阿尤丝+ carbokev +ayous+桐大芯+ayous+ carbokev +阿尤丝 阿尤丝 阿尤丝 梧桐 5木+2碳   蝴蝶 Amultart 桧木+ZLC+淋巴+桐木+淋巴+ZLC+桧木 桧木 淋巴 梧桐 5木+2碳   蝴蝶 张继科ALC koto-arylate/carbon-limba-ayous-limba+arylate/carbon+koto koto 阿尤丝 梧桐 5木+2碳   蝴蝶 张继科ZLC koto+ Zylon Carbon +ayous+桐大芯+ayous+ Zylon Carbon +koto koto 阿尤丝 梧桐 5木+2碳   蝴蝶 张继科SZLC koto+ Super Zylon Carbon +ayous+桐大芯+ayous+ Super Zylon Carbon +koto koto 阿尤丝 梧桐 5木+2碳   蝴蝶 波尔ALC koto-arylate/carbon-limba-ayous-limba+arylate/carbon+koto koto 阿尤丝 梧桐 5木+2碳   蝴蝶 波尔ZLC koto+ Zylon Carbon +ayous+桐大芯+ayous+ Zylon Carbon +koto koto 阿尤丝 梧桐 5木+2碳   蝴蝶 波尔ZLF koto+ Zylon +ayous+桐大芯+ayous+ Zylon +koto koto 阿尤丝 梧桐 5木+2碳   蝴蝶 Boll Spark 淋巴+芳基+阿尤斯+阿尤斯+阿尤斯+芳基+淋巴 淋巴 阿尤丝 阿尤丝 5木+2碳   蝴蝶 波尔精神 koto+ carbokev +ayous+桐大芯+ayous+ carbokev +koto koto 阿尤丝 梧桐 5木+2碳   蝴蝶 水谷隼 limba+ zlc +limba+kiri+limba+ zlc +limba 淋巴 阿尤丝 梧桐 5木+2碳   蝴蝶 Viscaria KOTO(0.55mm)+ 芳基纤维(0.3mm)+ 阿尤丝（0.8mm） +桐木大心（3.8mm） koto 淋巴 阿尤丝 5木+2碳   蝴蝶 科贝尔 limba+limba+阿尤丝+limba+limba 淋巴 淋巴 阿尤丝 5木   蝴蝶 孔令辉 koto+云杉+阿尤丝+云杉+koto koto 云杉 阿尤丝 5木   蝴蝶 李菊 limba+limba+阿尤丝+limba+limba 淋巴 淋巴 阿尤丝 5木   蝴蝶 福原爱纯木 limba+limba+阿尤丝+limba+limba 淋巴 淋巴 阿尤丝 5木   蝴蝶 张怡宁 limba+limba+阿尤丝+limba+limba 淋巴 淋巴 阿尤丝 5木   蝴蝶 Primorac limba+limba+阿尤丝+limba+limba 淋巴 淋巴 阿尤丝 5木   锐科特 DJ200 椴木面材，桐木大芯 椴木 阿尤丝 油桐 5木   银河 E1 KOTO+云杉+阿尤斯 koto 云杉 阿尤丝 5木   银河 mc2 koto+云杉+阿尤丝+云杉+koto koto 云杉 阿尤丝 5木   银河 N10 淋巴+云杉+松木 淋巴 云杉 松木 5木   银河 U2 koto+阿尤丝+阿尤丝+阿尤丝+阿尤丝+阿尤丝+koto koto 阿尤丝 阿尤丝 7木     2014 年的数据，很多已经变更，仅提供参考，引用自这里，欢迎在评论里更新。\n"},{"id":2,"href":"/posts/use-typora-write-hugo-blog/","title":"使用 typora 来编辑你的 hugo 博客","section":"Posts","content":"最近 typroa 用的比较多，然后又想着继续维护在 github page 的博客，觉得把 typora 编辑完的东西再复制到博客项目里很麻烦，于是开始了一番折腾。\n目标是啥 在 typora 写的笔记放在了 iCloud，然后可以一键同步到我的线上博客\n使用 hugo hugo 是一个静态文件生成器 https://gohugo.io/\n首先你需要用 hugo 自己生成一个项目\nhugo new site quickstart 进入quickstart 并添加一个主题\ncd quickstart git init git submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke 复制下配置文件（后续可以定制）\necho \u0026#39;theme = \u0026#34;ananke\u0026#34;\u0026#39; \u0026gt;\u0026gt; config.toml 以下不需要做 不熟悉 hugo 的可以试着跑一下，创建一篇新的blog\nhugo new posts/my-first-post.md 随便写点东西\n--- title: \u0026#34;My First Post\u0026#34; date: 2019-03-26T08:47:11+01:00 draft: true --- hello, first blog 重点来了 hugo 的静态生成是可以指定项目外的content 路径的，比如我的文档在 iCloud 的地址是~/Library/Mobile\\ Documents/iCloud/typora/Blog ，通过下面命令可以在本地预览效果。\nhugo -c ~/Library/Mobile\\ Documents/iCloud/typora/Blog server 通过这条命令生成静态文档，hugo 会生成在public文件夹下\nhugo -c ~/Library/Mobile\\ Documents/iCloud/typora/Blog 我写了一个 deploy.sh 的脚本，在 hugo 项目下执行这个脚本就可以把你的 public 下的静态文件发布到你的 github page 了，注意把脚本中的项目地址改成你自己的。\n#!/bin/sh  # If a command fails then the deploy stops set -e printf \u0026#34;\\033[0;32mDeploying updates to GitHub...\\033[0m\\n\u0026#34; # Build the project. # hugo # if using a theme, replace with `hugo -t \u0026lt;YOURTHEME\u0026gt;` # Go To Public folder cd public git init git remote add origin git@github.com:tcitry/blog.git # Add changes to git. git add . # Commit changes. msg=\u0026#34;rebuilding site $(date)\u0026#34; if [ -n \u0026#34;$*\u0026#34; ]; then msg=\u0026#34;$*\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; # Push source and build repos. git push -f origin master # come back zero rm -rf .git cd .. 下面是我在 typora 的目录结构\n图片怎么办？ typora 集成了 uPic、PicGo 等图床工具，在 github 或者其他 oss 新开个图床，配置一下自动上传就可以了。\n总结 综上，这次剩下的，就真的只有开始写了。\n"},{"id":3,"href":"/posts/talk-about-django-rest-framework/","title":"浅谈 Django-REST-Framework 的设计与源码","section":"Posts","content":"最近又重新接触 DRF，翻看文档发现，当时很难理解的东西，如今一看就懂了，顺带看了源码，也比较容易理解，至少比 Django 的源码简单不少。下面开始从 DRF 的设计和源码两个方面，结合自己的看法，谈谈DRF。\nAPIView APIView 是 DRF 概念体系中最基本类视图，它基于 Django 的 View，同时又实现了一层对自己创造的概念的封装，比如permission_classes，render_classes，authentication_classes等，相当于请求过来后又进入一层，过滤（验证、初始化）完要走的这些classes，才能执行到我们自己实现的 view。\nMixin 在介绍 Generic view 前先说一下 mixin。说白了，官方给的案例里面的 mixin，就是对 model 的object增删改查的原子操作。比如RetrieveModelMixin，通过 get_object 先获取到对象，然后通过 serializer 拿到序列化数据。\nclass RetrieveModelMixin(object): \u0026#34;\u0026#34;\u0026#34; Retrieve a model instance. \u0026#34;\u0026#34;\u0026#34; def retrieve(self, request, *args, **kwargs): instance = self.get_object() serializer = self.get_serializer(instance) return Response(serializer.data) 延伸开来，Mixin 是一个非常重要的概念，因为它是模块化拆分后最关键的原子逻辑实现，是每一个单独的块。试想下，我们可以通过这些小块拼接成不同的功能，比如用户注册功能，使用者有可能在手机注册，有可能在web注册，在 Django 后端中可能需要提供两套 view 层接口，甚至还有渲染 template 的实现，但是真正的逻辑处理上，可以只调用一个RegistMixin的东西，从而提高代码复用，降低维护成本。\n甚至，Mixin 可以重写同时继承的 GenericAPIView 中的实现，比如 request 参数处理，Response 数据处理（视频、文件格式之类），get_queryset，get_serializer 等等有通用需求，并且会在多个地方复用的定制，比如根据传入参数指定需要的 serializer 从而在 mixin 中重写 get_serializer 方法的实现逻辑。总之，原本会在 View 中发生的一切，都可以通过 Mixin 封装起来，或重写、或新的逻辑实现。\nGeneric views 典型的Generic view就是这样的，本质上是类视图，它由一些 Mixin 组成，这里的ListModelMixin实现了list()方法，并同时继承自GenericAPIView，同时自己实现了由 get() 到 list() 的转发。复杂的是，GenericAPIView 实现，以及他的执行过程，和后期对里面函数的重写、定制。所以抽时间多研究下这里很值得，以后也会节省大量时间。\nclass ListAPIView(mixins.ListModelMixin, GenericAPIView): \u0026#34;\u0026#34;\u0026#34; Concrete view for listing a queryset. \u0026#34;\u0026#34;\u0026#34; def get(self, request, *args, **kwargs): return self.list(request, *args, **kwargs) 如果要实现的逻辑不是很复杂的话，直接在view中继承一个[List[Create[Update]]]APIView，然后指定下serializer_class，permission_class，queryset等就可以了。对DRF熟悉的话相信这种方式实现功能会很快。\nViewsets 先看代码，ViewSet 继承了ViewSetMixin和APIView，ViewSetMix是APIView中as_view的重写，实现请求到 action 的转发，虽然 Django 自带的 View 也实现了 as_view，但只是传递初始化参数，确实没有这个请求转发到 action 的实现，APIView里面也没有。这里也可以学习到：Python的多重继承中，子类形参的先后顺序，影响到执行的是哪个类中的as_view方法，相当于ViewSetMixin又继承了APIView。\nclass ViewSet(ViewSetMixin, views.APIView): \u0026#34;\u0026#34;\u0026#34; The base ViewSet class does not provide any actions by default. \u0026#34;\u0026#34;\u0026#34; pass viewsets 和 APIView 不一样的地方在于，它要表达的更多的是一个方法视图的集合，他的内部是已经实现了的list()，retrieve()，delete()，update()的实现，如果实现用 DRF 的 DefaultRouter。router和as_view都可以实现GET请求\u0026ndash;\u0026gt;list()的转发，值得一提的还有detail_route和list_route(最新版本推荐使用action)，他们需要在urls中配置 router 的前提下使用，在 Router 类的get_url里面的get_routers执行，然后获得所有的路由列表，再进行 action 转发。\n# account/views.py class AccountViewSet(viewsets.ModelViewSet): \u0026#34;\u0026#34;\u0026#34; 对Account的操作的集合，本质上是基于方法视图的封装 \u0026#34;\u0026#34;\u0026#34; queryset = User.objects.all() serializer_class = UserSerializer @detail_route(methods=[\u0026#39;post\u0026#39;], url_path=\u0026#39;change-password\u0026#39;) def set_password(self, request, *args, **kwargs): \u0026#34;\u0026#34;\u0026#34; 修改用户的密码 \u0026#34;\u0026#34;\u0026#34; return Response(status=status.HTTP_200_OK) @detail_route(methods=[\u0026#39;post\u0026#39;], url_path=\u0026#39;change-username\u0026#39;) def change_username(self, request, *args, **kwargs): \u0026#34;\u0026#34;\u0026#34; 修改用户的用户名 \u0026#34;\u0026#34;\u0026#34; return Response(status=status.HTTP_200_OK, data={\u0026#39;msg\u0026#39;: \u0026#39;changed\u0026#39;}) # account/urls.py router = routers.SimpleRouter() router.register(r\u0026#39;\u0026#39;, views.AccountViewSet, base_name=\u0026#39;user\u0026#39;) urlpatterns = router.urls 以上代码，直接实现了对 account 的增（create）删（delete）改（update）和 account 列表（list），同时我又添加了set_password和change_username方法。这种形式没接触过的话很难理解，但是却很实用，尤其一个 model 有频繁的不同功能需求的时候，如果写SetPasswordView和ChangeUsernameView这样类视图的实现，未免会很麻烦，这个时候 viewsets 就是很好的选择。\nSerializers class TopicListSerializer(serializers.ModelSerializer): class Meta: model = models.TopicModel fields = \u0026#39;__all__\u0026#39; read_only_fields = (\u0026#39;id\u0026#39;, \u0026#39;author_id\u0026#39;) Serializer 相当于 View 和 Model 的中间层，避免 view 频繁直接操作 model object 的同时，规范数据字段格式、内容、validator、提供序列化数据等等，同时可以定义方法实现对 model 的特定操作。serializer 不适合处理业务逻辑，它要做的就是对数据传入传出的处理，保证数据正确。通常为了验证和序列化各项数据，serializer 的代码加上 validator 也集中了较大的工作量。\n其它 DRF 最主要的就是上面提到的一些概念，也许在刚接触 Django Web 的话没有接触过，但是这应该是 DRF 中最常用的。其他的比如 router、Throttling、validator 也比较实用，甚至也是必须掌握的，但是 DRF 的文档写的确定很详细，使用方法不再介绍。\n总结 我的理解，DRF 是基于 “Don\u0026rsquo;t repeat yourself” 原则，提出一个Web开发的规范，它代码里提供了规范的接口，和最基础的使用例子，而在实际的复杂逻辑开发中，需要的是对各种概念的 “custome” 定制，几乎文档每一页都提供了定制的介绍。实际的应用里面不会是简单的增删改查，而是需要走一定的逻辑处理后的增删改查，同时还有对基础操作频繁的复用。DRF通过把web业务系统中会出现的每一步流程拆分，进行模块化，概念化，让开发者知道需要开发的业务属于哪一种概念，放到哪一个模块下面，从而在DRF的大框架下特定的位置编写，这样减少了一份功能多份代码实现的麻烦，也因为规范化 coding 提高了开发者的效率。\n当然DRF也有缺点，它对新手不够友好，一些封装太极致，以至于不容易明白程序的执行流程，比如我初次看viewsets、GenericAPIView的时候。\n最后我基于DRF的文档，学习过程中写了一个论坛demo：DRForum的论坛例子，可以直接runserver调试。通过127.0.0.1:8000/docs可以查看汇总的接口，这里使用了DRF Docs。\n"},{"id":4,"href":"/posts/ubuntu-MariaDB/","title":"Vagrant 虚拟机 Ubuntu16.04 安装 MariaDB","section":"Posts","content":"由于宿主机安装了 MySQL，为了避免安装 MariaDB 造成 MySQL 无法使用，所以在 Vagrant 中安装 Mariadb。\n更换网易 apt-get 源 /etc/apt/sources.list\n读取源软件列表 sudo apt update\n更新软件版本 sudo apt upgrade\n安装 MariaDB sudo apt install mariadb-server\n安全性设置更新 root 密码 sudo mysql_secure_installation\n服务器开始远程登陆：my.cnf 中bind_address改为 0.0.0.0\n为登陆用户开启远程登陆权限：\n\u0026gt;\u0026gt;GRANT ALL PRIVILEGES ON *.* TO myuser@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;mypassword\u0026#39; WITH GRANT OPTION; \u0026gt;\u0026gt;FLUSH PRIVILEGES; 重启 MariaDB service mysql restart\nVagrantfile 中 config.vm.network\nconfig.vm.network \u0026quot;forwarded_port\u0026quot;, guest: 3306, host: 8306 重启 Vagrant 虚拟机 vagrant reload\n最后在宿主机连接 MariaDB 的命令：\nmysql -u root -h 127.0.0.1 -P 8306 -p 期间遇到无法 reset MariaDB 的 root 用户的密码，通过这里解决了，大致就是在安全模式下登陆，清空 root 的 plugin，然后将密码写入表中。\n"},{"id":5,"href":"/posts/ubuntu-deploy-django/","title":"Ubuntu 下部署 Django 应用","section":"Posts","content":"做了一个Django小应用，主要内容是一个论坛，经过好几天的研究，也可以在服务器端运行了，以下所有代码中的操作都需要在命令行运行。\n安装MySQL apt-get update apt-get install mysql-server mysql-client 根据提示设置 MySQL root用户密码\nMySQL设置中文utf8格式 一般在/etc/mysql下\n[client]下添加default-character-set=utf8\n[mysqld]下添加character-set-server=utf8\n[mysql]下添加default-character-set=utf8\n重启MySQL\nservice mysql restart 进入MySQL查看编码\nshow variables like \u0026#39;char%\u0026#39;; 为MySQL建立远程连接 由于修改数据库时不可能频繁的登服务器在命令行下修改，远程用workbench连接MySQL服务器是更方便的选择，先登入MySQL，授权一个可以远程连接这个数据库的用户名和密码。\n\u0026gt;\u0026gt;GRANT ALL PRIVILEGES ON *.* TO myuser@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;mypassword\u0026#39; WITH GRANT OPTION; \u0026gt;\u0026gt;FLUSH PRIVILEGES; 有的MySQL没有开放远程连接的端口，只允许本地连接，你需要查看my.conf之类的文件，我的在/etc/mysql/my.conf把\nbind-address:127.0.0.1 那行注释掉即可\n安装pip 下载地址\napt-get install python-pip 安装django1.7 django官网\npip install Django==1.7 python进入python2.7解释器\n\u0026gt;\u0026gt;import django \u0026gt;\u0026gt; 不出错说明安装成功\n安装mysql-python 安装mysql-python注意需要配置mysql_config我的在(/usr/bin目录下，其他的类似也在bin目录下，视不同系统不同版本而定)如果 /usr/bin目录下没有mysql_config，需要安装mysql开发包\napt-get install python-setuptools apt-get install libmysqld-dev apt-get install libmysqlclient-dev apt-get install python-dev 下载链接\nwget \u0026#39;url\u0026#39; 解压zip文件，首先安装unzip\napt-get install unzip unzip mysql-python.zip cd mysql-python vi site.cfg 把mysql_config路径那行取消注释，路径为/usr/bin/mysql_config\ncd .. python setup.py build python setup.py install 进去python解释器\n\u0026gt;\u0026gt;import MySQLdb \u0026gt;\u0026gt; 不报错说明安装成功\nMySQLdb不支持python3，可以试试pymysql，同时在Python3的项目中，需要在__init__.py中添加\nimport pymysql pymysql.install_as_MySQLdb() 这是由于Django调用MySQL的接口问题，在setting.py文件中具体为'ENGINE': 'django.db.backends.mysql',，仔细查看这句代码就会发现Django默认调用的是MySQLdb，虽然它只支持Python2.0。\n配置nginx 最重要的就是nginx的配置\n我的配置目录在/etc/nginx/nginx.conf和/etc/nginx/sites-enable/*后者可以在前者文件中设置，先查看配置文件/etc/nginx/sites-enable/django\n根据自己的应用修改配置文件中static路径，server_name，root等。修改完毕注意要service nginx reload\n关于静态文件的地址配置还是需要多说一句，nginx中的/static目录对应的是setting.py文件中的STATIC_ROOT目录，两个写一样的，执行python manage.py collectstatic收集的文件是admin后台模块的静态样式文件，执行完后这些静态文件就被复制在你设置的STATIC_ROOT目录了。\n部署代码 因为我的代码在github，先安装git\napt-get install git git clone https://github.com/tcitry/dlpucsdn.git 部署以后注意修改数据库密码，邮件服务器密码，debug模式False，template_debug模式为False。\nvirtualenv pip install virtualenv 根据网上现有的教程简单看看virtualenv的使用很容易理解，在项目依赖的相关程序配置过程中需要始终开着virtualenv。\n配置Gunicorn 查看这个文档修改为自己的应用参数\nservice gunicorn restart 当部署一个应用时可以将配置文件放在/etc/init.d/gunicorn.conf文件里面。但同时部署多个文件的时候，可以使用supervisor+gunicorn+virtualenv的部署方式，这样可以在每个不同的项目目录利用virtualenv为每个应用配置不同的环境，同时可以使服务器的环境更加易于管理。\n先在项目的根目录测试一下，确保gunicorn安装正确，\n../bin/gunicorn myapp.wsgi:application 不出错就说明正确了，出错一般是提示没有那个module名，检查一下django是否安装，执行命令的文件目录是否正确。\nsupervisor的使用 apt-get install supervisor sudo vim /etc/supervisord.conf 编辑的内容如下，请自行修改项目和目录名。\n[program:classroom] command = sh /home/projects/classroom/classroom/gunicorn_start user = root redirect_stderr = true autorestart = true 配置这个gunicorn_start.sh\ncd /home/projects/classroom/classroom ../bin/gunicorn classroom.wsgi:application -w 4 -b :8000 启动supervisor\n/etc/init.d/supervisord start 其他方式\nsupervisorctl start \u0026lt;name\u0026gt; supervisorctl stop \u0026lt;name\u0026gt; 安装七牛云SDK 由于网站的静态存储要用七牛云，在运行程序前要安装否则报错没有qiniu SDK的方法。\npip install qiniu 七牛云安装前注意安装的版本，我被坑过一次，写程序时是6.0版本，部署时都7.0了，接口全都不一样。\n还有 还有不推荐cloudflare等国外CDN加速，亲身体验。\n还有推荐下这篇来自digitalocean的部署实例\n"},{"id":6,"href":"/about/","title":"About","section":"Yindongliang","content":"关于博客 本博客使用基于 Hugo 的 hugo-book 主题 部署在 Github Page。\n关于我 曾经使用 Python，现在使用 Go 的后端程序员，正在学习前端知识，现居北京。\n业余喜欢打乒乓球，欢迎线下约球~\n"},{"id":7,"href":"/docs/","title":"Docs","section":"Yindongliang","content":"日常笔记，请直接查阅左侧目录\n"},{"id":8,"href":"/docs/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/","title":"堆","section":"数据结构","content":"堆（优先队列）\n堆（heap）分为最大堆（大根堆）和最小堆（小根堆）。\n特点 （1）在最大堆中，父节点的值比每一个子节点的值都要大。在最小堆中，父节点的值比每一个子节点的值都要小。\n（2）满足完全二叉树的特性：在当前层级所有的节点都已经填满之前不允许开始下一层的填充。\n堆属性非常有用，因为堆常常被当做优先队列使用，因为可以快速地访问到“最重要”的元素。\n堆通常以数组形式的存储，而非二叉树的链式存储。\n如图，这是一个最大堆，转化为数组之后：[ 10, 7, 2, 5, 1 ]，故堆的查找的时间复杂度为 O(1)。\n索引 i 满足这样的映射关系：\nparent(i) = floor((i - 1)/2) left(i) = 2i + 1 right(i) = 2i + 2 在堆中，在当前层级所有的节点都已经填满之前不允许开是下一层的填充，所以堆总是有这样的形状：\n规律 如何找到父节点？n/2\n如何找到左节点和右节点？左：2n，右2n+1\n如何确定叶子节点 i \u0026gt; n/2\n和树的区别 节点的顺序在二叉搜索树中，左子节点必须比父节点小，右子节点必须必比父节点大。但是在堆中并非如此。在最大堆中两个子节点都必须比父节点小，而在最小堆中，它们都必须比父节点大。\n内存占用普通树占用的内存空间比它们存储的数据要多。你必须为节点对象以及左/右子节点指针分配内存。堆仅仅使用一个数组来存储数据，且不使用指针。\n平衡二叉搜索树必须是“平衡”的情况下，其大部分操作的复杂度才能达到O(log n)。你可以按任意顺序位置插入/删除数据，或者使用 AVL 树或者红黑树，但是在堆中实际上不需要整棵树都是有序的。我们只需要满足堆属性即可，所以在堆中平衡不是问题。因为堆中数据的组织方式可以保证O(log n) 的性能。\n搜索在二叉树中搜索会很快，但是在堆中搜索会很慢。在堆中搜索不是第一优先级，因为使用堆的目的是将最大（或者最小）的节点放在最前面，从而快速的进行相关插入、删除操作。\n参考  https://www.jianshu.com/p/6b526aa481b1  题目   剑指 Offer 40. 最小的k个数   215. 数组中的第K个最大元素    "},{"id":9,"href":"/docs/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84/","title":"数组","section":"数据结构","content":"数组常被用来当做栈和队列的容器。\n另外还有一些算法可以通过数组实现，比如堆。\n"},{"id":10,"href":"/docs/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","title":"栈和队列","section":"数据结构","content":"栈 先进后出，后进先出\n队列 先进先出，后进后出\n（双端队列）\n数组 "},{"id":11,"href":"/docs/Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/","title":"树","section":"数据结构","content":"基本概念 父节点\n子节点\n叶子节点\n高度\n深度\n 树的高度：节点到叶子节点的最大值就是其高度。 树的深度：高度和深度是相反的，高度是从下往上数，深度是从上往下。因此根节点的深度和叶子节点的高度是 0  二叉树的一些基本特性  在二叉树的第i层上至多有$ 2 ^ { i-1 } $个结点（i\u0026gt;=1）   二叉树遍历 指的是根节点的遍历顺序\n 前序遍历 中序遍历 后序遍历 层序遍历(BFS)  举例：已知先序遍历、中序遍历，求后序遍历\n构建二叉树  105. 从前序与中序遍历序列构造二叉树 106. 从中序与后序遍历序列构造二叉树 889. 根据前序和后序遍历构造二叉树  满二叉树 对于满二叉树，除最后一层无任何子节点外，每一层上的所有结点都有两个子结点二叉树。\n完全二叉树 定义1：若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。\n定义2：对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。\n二叉搜索树 特点：\n 左子树的所有节点值小于根的节点值（注意不含等号） 右子树的所有节点值大于根的节点值（注意不含等号） 没有键值相等的节点  由此可得：\n二叉搜索树的中序遍历结果是一个有序列表，这个性质很有用。\n但是二叉搜索树不一定平衡，因此引申出平衡二叉搜索树。\n平衡二叉查找树可以修复二叉查找树形状不规则的问题。\n平衡二叉树（AVL 树） 平衡二叉树具有搜索二叉树的性质，同时又多了以下特性：\n特性 除了空树，任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过 1。\n平衡二叉树在插入新的子节点时，可能会形成最小失衡子树。\n平衡二叉树的失衡调整主要是通过旋转最小失衡子树来实现的。根据旋转的方向有两种处理方式，左旋 与 右旋 。\nB 树 B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树（查找路径不只两个）\nB+树 B*树 红黑树 R 树 Trie 前缀树（字典树） 参考  https://zhuanlan.zhihu.com/p/56066942 https://zhuanlan.zhihu.com/p/27700617 https://www.jianshu.com/p/e136ec79235c  "},{"id":12,"href":"/docs/Algorithms/%E6%96%B9%E6%B3%95%E6%8A%80%E5%B7%A7/%E9%80%92%E5%BD%92/","title":"递归","section":"方法技巧","content":"反转字符串\n"},{"id":13,"href":"/docs/Algorithms/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","title":"二分查找","section":"算法","content":"二分查找利用已经排好序的数组，每次查找可以将查找范围减半，查找范围内只剩一个数据时查找结束。\n"},{"id":14,"href":"/docs/Algorithms/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","title":"动态规划","section":"算法","content":"必备因素：递归\n"},{"id":15,"href":"/docs/Algorithms/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","title":"排序算法","section":"算法","content":"冒泡排序 选择排序 插入排序 堆排序 归并排序 快速排序 希尔排序 桶排序 "},{"id":16,"href":"/docs/Algorithms/%E7%AE%97%E6%B3%95/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/","title":"滑动窗口","section":"算法","content":"例题\n3. 无重复字符的最长子串\n"},{"id":17,"href":"/docs/Apple/Objective-C/","title":"Objective C","section":"macOS/iOS","content":"数据类型\n数据结构\n程序控制\nswitch\nselect\n函数调用\n“面向对象”\n进阶语法\n条件编译\n#if defined(A)\n#elif\n#ifndef\n#else\n#endif\n成员变量名命名规范：_开头\n局部变量不用，易于区分\n类方法+开头（不用创建对象）\n[类名 类方法]\n对象方法-开头\n[对象名 方法名]\nself指向当前对象的指针\n不允许子类和父类中拥有相同的成员变量\n继承\n@interface Car:Animal继承自Animal类\nSuper 调用父类的方法\n点语法，.方法调用\nP.age=10;等效\n[p setAge:10]\nInt a = p.age;\n[p getAge:10]\nObject-c\nBOOL 布尔类型相比c语言新添加\n声明用到的#import\n类的声明@interface Car :NSObject让这个类具备创建对象的能力\n@public使成员变量访问\n@end\n类的实现@implementation\n@end\n类中的方法[p run]\noc中函数和方法很不一样,本质区别在哪？\noc方法中任何数据类型都要小括号括住\nCar new创建一个新对象并返回一个地址\n在方法声明中参数\n-(void)sumwith:(int)num1 with:(int)num2 and:(int)num3;\n这个方法就叫sumwith:with:and:\n调用时[Car sumwith:10 with:20 and:20]\n匿名对象：同java\n成员变量访问权限\n@public任何地方访问\n@private只能在当前方法中访问\n@protect能在当前类和子类的对象中访问\n@package 处在同一个框架中就能访问\n@implementation中新定义的成员变量直接就是私有的。\n@autoreleasepool关于内存管理\n@property自动生成某个成员变量，set和get方法的声明\n@property int age自动生成一个_age的变量\n@synthesize 自动生成property声明的实现\n@synthesize age=_age\nId == NSObject * 万能的指针\nid中包含* id d = [person new]\n分类category\n一个类由多个人来写(奇葩)分类分模块\n在不改变类的基础上，只可以为类增加新的方法，不能增加成员变量，但是可以访问\n分类中有类的方法时。分类中的方法优先级最高，最后去父类中找 ，最后参与编译的分类优先调用\n+方法名 类方法 不用创建实例就可以调用\n+load\n+initialize方法\n"},{"id":18,"href":"/docs/Apple/Swift/","title":"Swift","section":"macOS/iOS","content":"参考  中文版 Apple 官方 Swift 教程《The Swift Programming Language》 https://swiftgg.gitbook.io/swift/   数据类型\n类型转换\n数据结构\n程序控制\nfor/break/continue for\u0026hellip;in\u0026hellip;\nlet names = [\u0026#34;Anna\u0026#34;, \u0026#34;Alex\u0026#34;, \u0026#34;Brian\u0026#34;, \u0026#34;Jack\u0026#34;] for name in names { print(\u0026#34;Hello, \\(name)!\u0026#34;) } switch\nselect\n函数调用\n“面向对象”\n进阶语法\ngoto\n下标 subscript\n闭包 闭包的函数体部分由关键字 in 引入。该关键字表示闭包的参数和返回值类型定义已经完成，闭包函数体即将开始。\n断言 assert 使用断言进行调试 只在 debug 下生效\nprecondition 强制先决条件 debug 和 release 都生效\n# 的使用 # 在函数（或者方法）的参数名前添加\u0026rdquo;#\u0026quot;，可以使该参数拥有相同的本地参数名和外部参数名。函数（或方法）调用时强制使用外部参数名，否则编译错误。\n_ 的使用 _ 下划线可以用来省略外部参数名\n特性（@） @objc @main $ 的使用 访问控制  open public internal fileprivate private  "},{"id":19,"href":"/docs/Docker/Compose/","title":"Compose","section":"Docker","content":"命令 docker-compose run up -d --build "},{"id":20,"href":"/docs/Docker/Dockerfile/","title":"Dockerfile","section":"Docker","content":"各语言打包举例 Golang FROMgolang:1.12.17 AS build-env ADD . /go/src/gitlab.com/tcitry/gogogo WORKDIR/go/src/gitlab.com/tcitry/gogogo RUN go build -o /build/gogogo main.go FROMgolang:1.12.17 COPY --from=build-env /build/gogogo /data/src/ COPY conf/test.toml /data/src/ COPY entrypoint.sh /data/src/ EXPOSE5555 ENTRYPOINT [\u0026#34;/data/src/entrypoint.sh\u0026#34;] #!/bin/sh  mv test.toml config.toml if [ -z $COMMAND ]; then if [ ! -z $1 ] ; then COMMAND=$@ fi exec /data/src/gogogo $COMMAND else exec /data/src/gogogo $COMMAND fi Python FROMpython:3.6 WORKDIR/data/src COPY ./requirements.txt /data/src/requirements.txt RUN pip3 install -r requirements.txt COPY . /data/src COPY .env.example .env COPY ./docker-entrypoint.sh /entrypoint.sh ENTRYPOINT [\u0026#34;/entrypoint.sh\u0026#34;] #!/bin/bash  case \u0026#34;$1\u0026#34; in runserver) exec python3 manage.py \u0026#34;$@\u0026#34; ;; esac if [ -z $1 ] ; then exec gunicorn -b 0.0.0.0:8000 -w 4 -t 90 -p /var/run/project.pid project.wsgi:application fi "},{"id":21,"href":"/docs/FE/Deno/%E5%91%BD%E4%BB%A4%E8%A1%8C/","title":"命令行","section":"Deno","content":"资源参考 Deno中文手册\nDeno手册\n命令行  --allow-read：打开读权限，可以指定可读的目录，比如--allow-read=/temp。 --allow-write：打开写权限。 --allow-net=google.com：允许网络通信，可以指定可请求的域，比如--allow-net=google.com。 --allow-env：允许读取环境变量。  "},{"id":22,"href":"/docs/FE/Electron/%E5%9F%BA%E7%A1%80/","title":"基础","section":"Electron","content":"https://www.electronjs.org/\n"},{"id":23,"href":"/docs/FE/JavaScript/%E4%B8%89%E6%96%B9%E5%BA%93/","title":"三方库","section":"JavaScript","content":"工具库 lodash\n"},{"id":24,"href":"/docs/FE/JavaScript/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","title":"基本语法","section":"JavaScript","content":"概念 DOM、BOM、Window、Document DOM 是操作文档的 API，Document 是其一个对象。\nBOM 是操作浏览器的 API，Window 是其一个对象。\nfunction component(s) { const element = document.createElement(\u0026#39;div\u0026#39;); element.innerHTML = s; return element; } document.body.appendChild(component(\u0026#34;hello\u0026#34;)); SSR vs CSR 语法 var 和 let var 在全局级别（函数外部）进行声明会自动变成 Window对象的一个属性：\nvar name = \u0026#34;John\u0026#34;; window.name === name // true let 或者 const 则不会：\nvar name = \u0026#34;John\u0026#34;; window.name === name // false var 存在变量提升现象：闭包或函数内部重新声明后会对外部相同变量进行覆盖。\n匿名函数和箭头函数 深入理解箭头函数\nthis 作用域\nmodule 模块 export+import (ES6) export\nexport function hello (s) { return `hello, ${s}`; } import xxx from \u0026lsquo;xxx\u0026rsquo;\n\u0026lt;!doctype html\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import {hello} from \u0026#39;./hello.js\u0026#39; alert(hello(\u0026#34;js\u0026#34;)); \u0026lt;/script\u0026gt; \u0026lt;script nomodule\u0026gt; alert(\u0026#34;no module\u0026#34;); \u0026lt;/script\u0026gt; nomodule\n旧时的浏览器不理解 type=\u0026quot;module\u0026quot;, 会运行nomodule的代码块，支持 module 的浏览器不会运行该代码块。\n与 Node.js 中 exports 和 required 区别\nNode.js 如何处理 ES6 模块\nexports+require (node.js) with 严格模式下不允许使用 with 语句，否则将视为语法错误\nvar qs = location.search.substring(1); var hostName = location.hostname; var url = location.href; // 等效于  with(location){ var qs = search.substring(1); var hostName = hostname; var url = href; } switch 省略 break 关键字会执行下一个 case\nswitch (expression) { case value: statement break; case value: statement break; case value: statement break; case value: statement break; for\u0026hellip;of for (const element of [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]) { console.log(element); } 函数 生成器函数 调用一个生成器函数并不会马上执行它里面的语句，而是返回一个这个生成器的 迭代器 （ iterator ）对象。当这个迭代器的 next() 方法被首次（后续）调用时，其内的语句会执行到第一个（后续）出现yield的位置为止，yield 后紧跟迭代器要返回的值。或者如果用的是 yield*（多了个星号），则表示将执行权移交给另一个生成器函数（当前生成器暂停执行）。\narrow function 和 keyword function区别 typeof arguments对象 (function() { for (let argument of arguments) { console.log(argument); } })(1, 2, 3); // 1 // 2 // 3 arguments 对象 function foo(n) { var f = () =\u0026gt; arguments[0] + n; // 隐式绑定 foo 函数的 arguments 对象. arguments[0] 是 n,即传给foo函数的第一个参数  console.log(f()); } foo(1); // 2 foo(2); // 4 foo(3); // 6 foo(3,2);//6 数据类型 Array\nlet iterable = [10, 20, 30]; String\nlet iterable = \u0026#34;boo\u0026#34;; Map\nSet\n严格模式 参考 Javascript 严格模式详解\n参考  现代 JavaScript 教程 https://zh.javascript.info/ ES6 入门教程 https://es6.ruanyifeng.com/ JavaScript - MDN https://developer.mozilla.org/zh-CN/docs/learn/JavaScript  "},{"id":25,"href":"/docs/FE/Nodejs/%E5%91%BD%E4%BB%A4%E8%A1%8C/","title":"命令行","section":"Nodejs","content":"npx npx使用教程\nNode 自带 npm 模块，所以可以直接使用 npx 命令。\nnpm 版本管理\n ~: 当安装依赖时获取到有新版本时，安装到 x.y.z 中 z 的最新的版本。即保持主版本号、次版本号不变的情况下，保持修订号的最新版本。 ^: 当安装依赖时获取到有新版本时，安装到 x.y.z 中 y 和 z 都为最新版本。 即保持主版本号不变的情况下，保持次版本号、修订版本号为最新版本。  "},{"id":26,"href":"/docs/FE/Vue/","title":"Vue","section":"前端","content":"文档 2.x官方中文文档 https://cn.vuejs.org/v2/guide/\n3.x 官方文档\nv-show\nv-model\nv-bind:key\n组件 props\ndata 有三种写法，都是定义函数，而不是属性。\nmethods\nv-model 数据双向绑定\n事件 v-on，简写 @\nclick\nVue UI "},{"id":27,"href":"/docs/Golang/%E5%91%BD%E4%BB%A4%E8%A1%8C/","title":"命令行","section":"Golang","content":"Golang 常用命令  官方文档 https://golang.org/cmd/go/  run go run main.go -mod选项，go help modules查看详细，-mod 在其他部分命令中也可指定，具体是 build, clean, get, install, list, run, and test\n vendor mod readonly  test 测试用例要求  文件名须以\u0026rdquo;_test.go\u0026quot;结尾 函数名须以\u0026quot;Test\u0026quot;打头，并且形参为 (t *testing.T)  运行命令\n// -v 打印 log go test -v xlsx_test.go xlsx.go go test ./... 参数 // 直接查看覆盖率 go test -cover // 输出统计信息文件 go test -coverprofile=profile.out // 也可以定义cover模式 go test -covermode=count -coverprofile=profile.out // 查看每个函数的覆盖率 go tool cover -func=profile.out // 在浏览器详细查看每行的测试覆盖情况 go tool cover -html=profile.out -covermode选项\n set: 每个语句是否执行？（默认） count: 每个语句执行了几次 atomic: 类似于 count, 但表示的是并行程序中的精确计数  pprof 和火焰图 生成 profile 文件的两种方式\n通过 pprof go tool pprof --seconds 25 http://localhost/debug/pprof/profile 通过 bench test go test -bench=\u0026#34;.*\u0026#34; -cpuprofile=cpu.profile ./ 生成文件后，查看分析结果\ngo tool pprof -http=:8081 cpu.profile 也可以直接通过 web 界面查看\ngo tool pprof -http=:6060 http://127.0.0.1:8080/debug/pprof/profile env 设置私有仓库 go1.13 以上有效\ngo env -w GOPRIVATE=\u0026#34;*.luojilab.com\u0026#34; go 1.13 以下\ngit config --global url.\u0026#34;git@xxx.luojilab.com:\u0026#34;.insteadOf \u0026#34;https://xxx.luojilab.com/\u0026#34; 参考  https://segmentfault.com/a/1190000021127791   build CGO_ENABLED=0 GOOS=linux go build -mod vendor -a -ldflags \u0026#34;-extldflags \u0026#39;-f\u0026#39;\u0026#34; -o main "},{"id":28,"href":"/docs/Golang/%E5%B7%A5%E5%85%B7%E5%8C%85/","title":"工具包","section":"Golang","content":"参考\n Go语言不完全工具列表   Json 序列化工具 Golang 的 json 包\nEasyjson https://github.com/mailru/easyjson\ngomock 根据接口生成 mock 文件\ngo-sqlmock\nSQL 生成工具 gendry\n"},{"id":29,"href":"/docs/Golang/%E6%A0%87%E5%87%86%E5%BA%93/","title":"标准库","section":"Golang","content":"Buildin 文档 https://golang.org/pkg/builtin\nuintptr 足够大、可以存放任何指针地址的类型。常用来将指针转换后进行寻址计算。\n uintptr is an integer type that is large enough to hold the bit pattern of any pointer.\nfunc Offsetof(x ArbitraryType) uintptr func Sizeof(x ArbitraryType) uintptr func Alignof(x ArbitraryType) uintptr  错误示例 func main(){ n := Num{i: \u0026#34;EDDYCJY\u0026#34;, j: 1} nPointer := unsafe.Pointer(\u0026amp;n) ... ptr := uintptr(nPointer) njPointer := (*int64)(unsafe.Pointer(ptr + unsafe.Offsetof(n.j))) ... } uintptr 类型不能存储在临时变量中。因为从 GC 的角度来看，uintptr 类型的临时变量只是一个无符号整数，并不知道它是一个指针地址。因此当满足一定条件后，ptr这个临时变量是可能被垃圾回收掉的。\nArbitraryType 表示任意类型，实际上是一个占位符\n ArbitraryType is here for the purposes of documentation only and is not actually part of the unsafe package. It represents the type of an arbitrary Go expression.\ntype ArbitraryType int  Fmt Printf 标准输出    动词 含义     %v 按值的本来值输出   %+v 在 %v 基础上，对结构体字段名和值进行展开   %#v 输出 Go 语言语法格式的值   %T 输出 Go 语言语法格式的类型和值   %% 输出 % 本体   %b 整型以二进制方式显示   %o 整型以八进制方式显示   %d 整型以十进制方式显示   %x 整型以十六进制方式显示   %X 整型以十六进制、字母大写方式显示   %U Unicode 字符   %f 浮点数   %p 指针，十六进制方式显示    参考\n https://books.studygolang.com/The-Golang-Standard-Library-by-Example/chapter01/01.3.html https://yourbasic.org/golang/fmt-printf-reference-cheat-sheet/  Reflect 获取一个结构体中某个字段的 tag 的信息\nfunc GetStructTagList(i interface{}, tag string) []string { v := reflect.ValueOf(i) t := reflect.TypeOf(i) count := v.NumField() var ret []string for i := 0; i \u0026lt; count; i++ { ret = append(ret, fmt.Sprintf(\u0026#34;%v\u0026#34;, t.Field(i).Tag.Get(tag))) } return ret } ValueOf\nTypeOf\nNumField\nSignal 监听一个信号：\nfunc main() { sigs := make(chan os.Signal, 1) done := make(chan bool, 1) signal.Notify(sigs, syscall.SIGINT) fmt.Println(\u0026#34;start...\u0026#34;) go func() { switch sig := \u0026lt;-sigs; sig.String() { case syscall.SIGINT.String(): done \u0026lt;- true default: fmt.Println(\u0026#34;unknown signal\u0026#34;) } }() for { \u0026lt;-done fmt.Println(\u0026#34;done\u0026#34;) break } } Sync Waitgroup   Add\n  Done\n  Wait\n  Mutex 写互斥锁   Lock\n  Unlock\n  func main() { var mutex sync.Mutex count := 0 for i := 0; i \u0026lt; 50; i++ { go func() { mutex.Lock() count++ mutex.Unlock() }() } time.Sleep(time.Second) fmt.Println(count) } // 50 RWMutex 读写互斥 A RWMutex is a reader/writer mutual exclusion lock. The lock can be held by an arbitrary number of readers or a single writer. The zero value for a RWMutex is an unlocked mutex.\nA RWMutex must not be copied after first use.\nIf a goroutine holds a RWMutex for reading and another goroutine might call Lock, no goroutine should expect to be able to acquire a read lock until the initial read lock is released. In particular, this prohibits recursive read locking. This is to ensure that the lock eventually becomes available; a blocked Lock call excludes new readers from acquiring the lock.\n Lock RLock RUnlock Unlock  RLock()为“读锁定”，调用“读锁定”后，不能有其他goroutine进行写操作，但是可以进行读操作。RUnlock() 为“读解锁”，调用“读解锁”后，会唤醒一个因为要进行“写锁定”而被阻塞的goroutine。\n当 mutex 在 struct 中时，则整个 struct 拥有互斥锁。\nOnce var once sync.Once once.Do(func() { fmt.Println(\u0026#34;init config ...\u0026#34;) }) Atomic func AddT(addr *T, delta T)(new T) func LoadT(addr *T) (val T) func StoreT(addr *T, val T) func SwapT(addr *T, new T) (old T) func CompareAndSwapT(addr *T, old, new T) (swapped bool) 使用 atomic 实现 CAS 乐观锁 Pool func test() { // 初始化一个pool \tpool := \u0026amp;sync.Pool{ // 默认的返回值设置，不写这个参数，默认是nil \tNew: func() interface{} { return 0 }, } // 看一下初始的值，这里是返回0，如果不设置New函数，默认返回nil \tfmt.Println(pool.Get()) fmt.Println(pool.Get()) // 设置一个参数1 \tpool.Put(1) pool.Put(1) // 获取查看结果 \tfmt.Println(pool.Get()) fmt.Println(pool.Get()) // 再次获取，会发现，已经是空的了，只能返回默认的值。 \tfmt.Println(pool.Get()) // 0 \t// 0 \t// 1 \t// 1 \t// 0 } Cond noCopy\n noCopy may be embedded into structs which must not be copied after the first use.\nhttps://github.com/golang/go/issues/8005#issuecomment-190753527\n Go中没有原生的禁止拷贝的方式，所以如果有的结构体，你希望使用者无法拷贝，只能指针传递保证全局唯一的话，可以这么干，定义 一个结构体叫 noCopy，要实现 sync.Locker 这个接口。\nMap Unsafe Pointer Alignof\nSizeof\nOffsetof\nArbitraryType（int）\nRuntime GOMAXPROCS  func GOMAXPROCS(n int) int GOMAXPROCS sets the maximum number of CPUs that can be executing simultaneously and returns the previous setting. If n \u0026lt; 1, it does not change the current setting. The number of logical CPUs on the local machine can be queried with NumCPU. This call will go away when the scheduler improves.\n 疑问\n 在本地设置了最大的 CPU 数量如何验证生效？   Gosched runtime.Gosched()用于让出CPU时间片。这就像跑接力赛，A跑了一会碰到代码runtime.Gosched()就把接力棒交给B了，A歇着了，B继续跑。\nfunc say(s string) { for i := 0; i \u0026lt; 2; i++ { fmt.Printf(\u0026#34;say: %s\\n\u0026#34;, s) runtime.Gosched() fmt.Println(s) } } func test() { fmt.Println(runtime.GOMAXPROCS(0)) go say(\u0026#34;world\u0026#34;) say(\u0026#34;hello\u0026#34;) } // 12 // say: hello // say: world // hello // say: hello // world // say: world // hello 因为say(\u0026ldquo;hello\u0026rdquo;)这句占用了时间，等它执行完，线程也结束了，say(\u0026ldquo;world\u0026rdquo;)就没有机会了。\n这里同时可以看出，go中的goroutins并不是同时在运行。事实上，如果没有在代码中通过 runtime.GOMAXPROCS(n) 指定使用多核的话，goroutins都是在一个线程里的，它们之间通过不停的让出时间片轮流运行，达到类似同时运行的效果。\nStack  func Stack(buf []byte, all bool) int Stack formats a stack trace of the calling goroutine into buf and returns the number of bytes written to buf. If all is true, Stack formats stack traces of all other goroutines into buf after the trace for the current goroutine.\n IO ioutil Bufio "},{"id":30,"href":"/docs/Golang/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/","title":"环境变量","section":"Golang","content":"环境变量 Example go env\nGO111MODULE=\u0026#34;auto\u0026#34; GOARCH=\u0026#34;amd64\u0026#34; GOBIN=\u0026#34;\u0026#34; GOCACHE=\u0026#34;/Users/yindongliang/Library/Caches/go-build\u0026#34; GOENV=\u0026#34;/Users/yindongliang/Library/Application Support/go/env\u0026#34; GOEXE=\u0026#34;\u0026#34; GOFLAGS=\u0026#34;\u0026#34; GOHOSTARCH=\u0026#34;amd64\u0026#34; GOHOSTOS=\u0026#34;darwin\u0026#34; GOINSECURE=\u0026#34;\u0026#34; GONOPROXY=\u0026#34;*.luojilab.com\u0026#34; GONOSUMDB=\u0026#34;*.luojilab.com\u0026#34; GOOS=\u0026#34;darwin\u0026#34; GOPATH=\u0026#34;/Users/yindongliang/go/go1.14.1/bin\u0026#34; GOPRIVATE=\u0026#34;*.luojilab.com\u0026#34; GOPROXY=\u0026#34;https://goproxy.cn\u0026#34; GOROOT=\u0026#34;/Users/yindongliang/go/go1.14.1\u0026#34; GOSUMDB=\u0026#34;sum.golang.org\u0026#34; GOTMPDIR=\u0026#34;\u0026#34; GOTOOLDIR=\u0026#34;/Users/yindongliang/go/go1.14.1/pkg/tool/darwin_amd64\u0026#34; GCCGO=\u0026#34;gccgo\u0026#34; AR=\u0026#34;ar\u0026#34; CC=\u0026#34;clang\u0026#34; CXX=\u0026#34;clang++\u0026#34; CGO_ENABLED=\u0026#34;1\u0026#34; GOMOD=\u0026#34;/Users/yindongliang/github/golang/ants/go.mod\u0026#34; CGO_CFLAGS=\u0026#34;-g -O2\u0026#34; CGO_CPPFLAGS=\u0026#34;\u0026#34; CGO_CXXFLAGS=\u0026#34;-g -O2\u0026#34; CGO_FFLAGS=\u0026#34;-g -O2\u0026#34; CGO_LDFLAGS=\u0026#34;-g -O2\u0026#34; PKG_CONFIG=\u0026#34;pkg-config\u0026#34; GOGCCFLAGS=\u0026#34;-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/tg/wm0sdf5x16xddmy4r63cs7fw0000gn/T/go-build097402637=/tmp/go-build -gno-record-gcc-switches -fno-common\u0026#34; GO111MODULE 文档 https://github.com/golang/go/wiki/Modules\nvgo 就是后来的 go module\n GO111MODULE=off 无模块支持，go 会从 GOPATH 和 vendor 文件夹寻找包。 GO111MODULE=on 模块支持，go 会忽略 GOPATH 和 vendor 文件夹，只根据 go.mod 下载依赖。 GO111MODULE=auto 在 $GOPATH/src 外面且根目录有 go.mod 文件时，开启模块支持。  GOPATH ~/go/bin 目录\nGOROOT ~/go 即 go 的安装路径，下面有bin，src，pkg等\nGOOS 和 GOARCH 参考 https://gist.github.com/asukakenji/f15ba7e588ac42795f421b48b8aede63\n打印 Go 支持的目标系统列表\ngo tool dist list GOARM "},{"id":31,"href":"/docs/Golang/%E8%AF%AD%E6%B3%95/","title":"语法","section":"Golang","content":"数据类型\n类型转换\n数据结构\n程序控制\nfor/break/continue\nfor 循环 go 中对字符串 for 循环得到的是索引和 int32 类型的数字\n进制 十六进制 0x 开头为十六进制\n八进制 0 开头为八进制\nswitch/case/default\nfallthrough\nselect/case/default\n“面向对象”\n进阶语法\ngoto\n单引号 单引号在 Golang 表示一个字符，使用一个特殊类型 rune 表示字符型。rune 为 int32 的别名，它完全等价于 int32，习惯上用它来区别字符值和整数值。rune 表示字符的 Unicode 码值。\n传值和传引用 值类型：int、float、bool、array、sturct等\n引用类型：slice，map，channel，interface，func，string等\n传参给函数时，外部的值类型无法被修改，引用类型会被修改。\nselect  除 default 外，如果只有一个 case 语句评估通过，那么就执行这个case里的语句； 除 default 外，如果有多个 case 语句评估通过，那么通过伪随机的方式随机选一个； 如果 default 外的 case 语句都没有通过评估，那么执行 default 里的语句； 如果没有 default，那么代码块会被阻塞，直到有一个 case 通过评估；否则一直阻塞  itoa 参考 https://studygolang.com/articles/22498\nslice 切片和数组 // 创建数组 var arr := []int{1,2,3} // 动态数组创建，类似创建数组，但是没有指定固定长度 var al []int //创建slice sl := make([]int,10) //创建有10个元素的slice sl:=[]int{1,2,3} //创建有初始化元素的slice 区别：\n 声明数组时，方括号内写明了数组的长度或者\u0026hellip;,声明slice时候，方括号内为空 作为函数参数时，数组传递的是数组的副本，而slice传递的是指针。  defer defer 的语句在 return 之后执行\n 多个defer的执行顺序为“后进先出”； 所有函数在执行RET返回指令之前，都会先检查是否存在defer语句，若存在则先逆序调用defer语句进行收尾工作再退出返回； 匿名返回值是在return执行时被声明，有名返回值则是在函数声明的同时被声明，因此在defer语句中只能访问有名返回值，而不能直接访问匿名返回值； return其实应该包含前后两个步骤：第一步是给返回值赋值（若为有名返回值则直接赋值，若为匿名返回值则先声明再赋值）；第二步是调用RET返回指令并传入返回值，而RET则会检查defer是否存在，若存在就先逆序插播defer语句，最后RET携带返回值退出函数；  ‍‍因此 defer、return、返回值三者的执行顺序应该是：return最先给返回值赋值；接着defer开始执行一些收尾工作；最后RET指令携带返回值退出函数。\n 后调用的 defer 函数会先执行：  后调用的 defer 函数会被追加到 Goroutine _defer 链表的最前面； 运行 runtime._defer 时是从前到后依次执行；   函数的参数会被预先计算；  调用 runtime.deferproc 函数创建新的延迟调用时就会立刻拷贝函数的参数，函数的参数不会等到真正执行时计算；    panic panic 能够改变程序的控制流，调用 panic 后会立刻停止执行当前函数的剩余代码，并在当前 Goroutine 中递归执行调用方的 defer；\nfunc test() { defer fmt.Println(\u0026#34;in main\u0026#34;) defer func() { defer fmt.Println(\u0026#34;in defer func\u0026#34;) defer func() { panic(\u0026#34;panic again and again\u0026#34;) }() panic(\u0026#34;panic again\u0026#34;) }() panic(\u0026#34;panic once\u0026#34;) } ➜ go run main.go test in defer func in main panic: panic once panic: panic again panic: panic again and again defer 是后进先出。panic 需要等defer 结束后才会向上传递。出现 panic 时候，会先按照defer的后入先出的顺序执行，最后才会执行panic。\nrecover recover 只能在 defer 里会生效\n panic 只会触发当前 Goroutine 的 defer； recover 只有在 defer 中调用才会生效； panic 允许在 defer 中嵌套多次调用；  internal package Type assertions package main import \u0026#34;fmt\u0026#34; func main() { var i interface{} = \u0026#34;hello\u0026#34; s := i.(string) fmt.Println(s) s, ok := i.(string) fmt.Println(s, ok) f, ok := i.(float64) fmt.Println(f, ok) f = i.(float64) // panic \tfmt.Println(f) } channel Go提供了range关键字，将其使用在channel上时，会自动等待channel的动作一直到channel被关闭，如下：\nticker := time.NewTicker(time.Minute * 5) for range ticker.C { doSomeThing() } 如下例子，ch 初始化以后，取出的值默认是 false。\nctx, cancel := context.WithTimeout(context.Background(), 3*time.Second) defer cancel() ch := make(chan bool) go func() { defer close(ch) //具体的任务，这里模拟做的任务需要1秒完成  time.Sleep(time.Second * 1) }() select { case \u0026lt;- ch: fmt.Println(\u0026#34;ch bool\u0026#34;, \u0026lt;- ch) case \u0026lt;- ctx.Done(): fmt.Println(\u0026#34;ctx done\u0026#34;) } // output: // ch bool false 带缓冲区和不带缓冲区的区 c1 := make(chan int) // 不带缓冲区 c2 := make(chan int, 100) // 带缓冲区  非缓冲 channel，channel 发送和接收动作是同时发生的  例如 ch := make(chan int) ，如果没 goroutine 读取接收者\u0026lt;-ch ，那么发送者ch\u0026lt;- 就会一直阻塞   缓冲 channel 类似一个队列，只有队列满了才可能发送阻塞  一个管道同时仅允许被一个协程读写。\n特殊注释 go:linkname //go:linkname 注释标签引导编译器在编译时将当前私有函数链接到指定的目标函数，也可以作用到变量上面\n举例:\ntime.Sleep() 声明在 time 包，但是实现在 runtime 包的 runtime.timeSleep()\n\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; time/sleep.go \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; package time // Sleep pauses the current goroutine for at least the duration d. // A negative or zero duration causes Sleep to return immediately. func Sleep(d Duration) \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; runtime/time.go \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; // timeSleep puts the current goroutine to sleep for at least ns nanoseconds. //go:linkname timeSleep time.Sleep func timeSleep(ns int64) { if ns \u0026lt;= 0 { return } gp := getg() t := gp.timer if t == nil { t = new(timer) gp.timer = t } t.f = goroutineReady t.arg = gp t.nextwhen = nanotime() + ns gopark(resetForSleep, unsafe.Pointer(t), waitReasonSleep, traceEvGoSleep, 1) } 注意：\n这种方式大部分只在 go 源码中会用到，如果要自己写的话，需要引入 unsafe 包，同时因为go build默认加会加上-complete参数，这个参数检查到没有方法体，在同级文件夹中还需要增加一个空的.s文件才能绕过这个限制\ngo:noescape 该指令指定下一个有声明但没有主体（意味着实现有可能不是 Go）的函数，不允许编译器对其做逃逸分析。\n一般情况下，该指令用于内存分配优化。因为编译器默认会进行逃逸分析，会通过规则判定一个变量是分配到堆上还是栈上。但凡事有意外，一些函数虽然逃逸分析其是存放到堆上。但是对于我们来说，它是特别的。我们就可以使用 go:noescape 指令强制要求编译器将其分配到函数栈上。\nnamed return value func f() (i int, s string) { i = 17 s = \u0026#34;abc\u0026#34; return // same as return i, s } https://tour.golang.org/basics/7\nhttps://yourbasic.org/golang/named-return-values-parameters/\n数学计算 位移计算 CGo 举例\npackage rand /* #include \u0026lt;stdlib.h\u0026gt; */ import \u0026#34;C\u0026#34; func Random() int { return int(C.random()) } func Seed(i int) { C.srandom(C.uint(i)) } "},{"id":32,"href":"/docs/Golang/%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83/","title":"语言规范","section":"Golang","content":"语言规范 控制 Goroutine 的生命周期\n使用 gofmt\nContext 一般作为第一个参数传参\ncopy struct 时需注意 slice 的拷贝\nDon\u0026rsquo;t Panic\npkg 里面的包最好有 example\n传值还是传指针？\nError 未处理\nShare memory by communicating; don\u0026rsquo;t communicate by sharing memory.\n在 go 出去的方法里加 recover\n参考  The Go Programming Language Specification 如何写出优雅 Go 语言代码 Effective Go Code Review Comments Go安全指南   "},{"id":33,"href":"/docs/Golang/%E9%9D%A2%E8%AF%95%E9%A2%98/","title":"面试题","section":"Golang","content":"面试题解析\n https://toutiao.io/posts/qepeli/preview   string 和 []byte 互转\nstring 不能直接和byte数组转换\nstring可以和byte的切片转换\n1,string 转为[]byte\nvar str string = \u0026ldquo;test\u0026rdquo;\nvar data []byte = []byte(str)\n2,byte转为string\nvar data [10]byte\nbyte[0] = \u0026lsquo;T\u0026rsquo;\nbyte[1] = \u0026lsquo;E\u0026rsquo;\nvar str string = string(data[:])\n"},{"id":34,"href":"/docs/Java/SpringBoot/","title":"Spring Boot","section":"Java","content":"spring page\n"},{"id":35,"href":"/docs/Java/%E8%AF%AD%E6%B3%95/","title":"语法","section":"Java","content":"Java\n"},{"id":36,"href":"/docs/Kafka/Kafka/","title":"Kafka","section":"Middleware","content":"概念 group group*.*id是一个字符串，唯一标识一个consumer group. consumer group下订阅的topic下的每个分区只能分配给某个group下的一个consumer\nQuestions  备份越多，性能越好吗？\n 备份越多，复制的压力会越大，但是灾备的能力就越强，第一个 leader 挂了可以上第二个。\n"},{"id":37,"href":"/docs/Kubernetes/kubectl/","title":"Kubectl","section":"Kubernetes","content":"commands "},{"id":38,"href":"/docs/Linux/Git/","title":"Git","section":"Linux","content":"merge rebase submodule git submodule foreach git pull\ngitconfig 文件\n"},{"id":39,"href":"/docs/Linux/Shell-%E8%84%9A%E6%9C%AC/","title":"Shell 脚本","section":"Linux","content":"Set\n"},{"id":40,"href":"/docs/Linux/%E5%91%BD%E4%BB%A4%E8%A1%8C/","title":"命令行","section":"Linux","content":"练习 统计 Python 项目中行数最多的N个文件\n find . -path ./venv -prune -o -name \u0026lsquo;*.py\u0026rsquo; |xargs wc -l|sort -r |tail -n +2|head -n 2|tail -n +5\n "},{"id":41,"href":"/docs/Python/Django/","title":"Django","section":"Python","content":"Django\n"},{"id":42,"href":"/docs/Python/%E5%B7%A5%E5%85%B7%E5%8C%85/","title":"工具包","section":"Python","content":"密码学\n"},{"id":43,"href":"/docs/Python/%E6%A0%87%E5%87%86%E5%BA%93/","title":"标准库","section":"Python","content":"Socket "},{"id":44,"href":"/docs/Python/%E8%AF%AD%E6%B3%95/","title":"语法","section":"Python","content":"魔法方法\nasync\n"},{"id":45,"href":"/docs/Rust/%E5%91%BD%E4%BB%A4%E8%A1%8C/","title":"命令行","section":"Rust","content":"Cargo "},{"id":46,"href":"/docs/TCPIP/TCPIP/","title":"T C P I P","section":"TCPIP","content":"无向连接\n有向连接\n"},{"id":47,"href":"/docs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","title":"设计模式","section":"Docs","content":"参考\n常用设计模式\n"},{"id":48,"href":"/docs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","title":"面向对象","section":"设计模式","content":"封装\n继承\n多态\n"},{"id":49,"href":"/projects/","title":"Projects","section":"Yindongliang","content":"django-api-permission 基于 Django Middleware 通过对 URL 进行正则匹配实现的一个 API 权限管理中间件。\ndjango-mirage-field 使用 AES 对称加密算法，基于 Django Model 开发的脱敏工具，它实现了在保存数据时加密、读取数据时解密的功能，同时支持使用 Django ORM 进行查询。\ndrforum 基于 django-rest-framework 实现的论坛后端 API demo。\njeecf-cli 基于 Python 的 click 库为 Jeecf 开发的命令行工具，配合 jeecf-server 实现在本地生成指定的代码模板。\n"},{"id":50,"href":"/docs/Apple/AppleScript/","title":"AppleScript","section":"macOS/iOS","content":"1\n"},{"id":51,"href":"/docs/CTF/","title":"CTF","section":"Docs","content":"Links  wargame 知乎总结 Awesome Platforms - github 新手友好的CTF靶场整理合集   "},{"id":52,"href":"/docs/FE/HTML/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","title":"HTML","section":"HTML","content":"常用标签 input 属性: name\n提交时发送给后端的 key 值，value为input 的 value\n"},{"id":53,"href":"/docs/FE/HTTP/","title":"HTTP","section":"前端","content":"跨源资源共享（CORS）\nCORS （Cross-Origin Resource Sharing，跨域资源共享）是一个系统，它由一系列传输的HTTP头组成，这些HTTP头决定浏览器是否阻止前端 JavaScript 代码获取跨域请求的响应。\nXMLHttpRequest\n浏览器对前端跨域做了哪些限制？\n浏览器缓存\ncookie 设置了过期时间：会被保存在硬盘中，过期了才会消失。\n没有设置过期时间：声明周期随着关闭浏览器结束。\nlocalstorage 将数据保存在客户端本地的硬件设备中，即使浏览器被关闭了，该数据仍然存在，下次打开浏览器访问网站时仍然可以继续使用。\nsessionstorage sessionStorage为临时保存，localstorage 为永久保存。\n"},{"id":54,"href":"/docs/FE/Koa/","title":"Koa","section":"前端","content":"Koa\u0026ndash;基于 Node.js 平台的下一代 web 开发框架\n"},{"id":55,"href":"/docs/Linux/","title":"Linux","section":"Docs","content":"命令行的艺术\n"},{"id":56,"href":"/docs/Apple/","title":"macOS/iOS","section":"Docs","content":"目录  swift 语法 swiftUI objective-c 学习笔记  "},{"id":57,"href":"/docs/Kafka/","title":"Middleware","section":"Docs","content":" Redis RabbitMQ Kafka  "},{"id":58,"href":"/docs/Python/","title":"Python","section":"Docs","content":"Python 笔记\n"},{"id":59,"href":"/docs/Database/SQL/","title":"SQL","section":"Database","content":"练习 select 最后不加 s 的话 SQL 会报错\nselect count(*) from (select count(user_id) from virtual_user_membership where expire_time \u0026gt; 1604976736 and category_code=\u0026#39;FB0080\u0026#39; group by user_id) s; having\ngroup by\npg Json 查询 order_activity 是一个长度为 1 的数组\nselect ((raw-\u0026gt;\u0026gt;\u0026#39;order_activity\u0026#39;)::json-\u0026gt;\u0026gt;0)::json-\u0026gt;\u0026gt;\u0026#39;promot_title\u0026#39; from chronosphere.sale_orderraw where order_id in (select id from chronosphere.einstein_order where sn=\u0026#39;xxx\u0026#39;); "},{"id":60,"href":"/docs/Apple/SwiftUI/","title":"SwiftUI","section":"macOS/iOS","content":"参考 https://github.com/Jinxiansen/SwiftUI\nScene\nView\nWindow\nVStack\n"},{"id":61,"href":"/docs/FE/TypeScript/","title":"TypeScript","section":"前端","content":"ss\n"},{"id":62,"href":"/docs/FE/Nodejs/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/","title":"基本概念","section":"Nodejs","content":" Node.js 中文网 http://nodejs.cn/   Node.js 是什么 基于事件驱动，非阻塞I/O，\n"},{"id":63,"href":"/docs/Database/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/","title":"基础概念","section":"Database","content":"锁 乐观锁\n悲观锁\n"}]